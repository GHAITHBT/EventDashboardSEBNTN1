<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analytics Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>
<style>
    :root {
        --primary: #4361ee;
        --secondary: #3a0ca3;
        --success: #2ecc71;
        --danger: #e74c3c;
        --warning: #f39c12;
        --info: #3498db;
        --light: #f8f9fa;
        --dark: #1e293b;
        --overdue-color: #c0392b;
        --canceled-color: #7f8c8d;
    }
    .header {
        background: linear-gradient(135deg, var(--primary), var(--secondary));
        color: white;
        padding: 15px 20px;
        border-radius: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
    }
    .header h1 {
        font-size: 1.5rem;
    }
    .header-btn {
        padding: 8px 15px;
        border-radius: 6px;
        cursor: pointer;
        color: white;
        background-color: rgba(255, 255, 255, 0.2);
        border: none;
        transition: background-color 0.3s;
    }
    .header-btn:hover {
        background-color: rgba(255, 255, 255, 0.3);
    }
    .filter-container {
        background: white;
        padding: 15px;
        border-radius: 10px;
        margin-bottom: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
</style>
<body class="bg-gray-50">
    <div class="container mx-auto p-6">
        <header class="header">
            <h1>Analytics Dashboard</h1>
            <div>
                <a href="/admin"><button class="header-btn">Back to Dashboard</button></a>
                <button id="exportExcel" class="header-btn">Export to Excel</button>
            </div>
        </header>

        <!-- Date Range Filter -->
        <div class="filter-container">
            <h3 class="text-lg font-semibold text-gray-700 mb-4">Filter by Date Range</h3>
            <div class="flex space-x-4">
                <input type="date" id="startDate" class="border rounded-lg p-2">
                <input type="date" id="endDate" class="border rounded-lg p-2">
                <button id="applyFilter" class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700">Apply Filter</button>
                <button id="resetFilter" class="bg-gray-600 text-white px-4 py-2 rounded-lg hover:bg-gray-700">Reset</button>
            </div>
        </div>

        <!-- Key Metrics Cards -->
        <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-8">
            <div class="bg-white p-6 rounded-lg shadow-lg">
                <h3 class="text-lg font-semibold text-gray-700">Total Events</h3>
                <p id="totalEvents" class="text-3xl font-bold text-blue-600 mt-2">0</p>
            </div>
            <div class="bg-white p-6 rounded-lg shadow-lg">
                <h3 class="text-lg font-semibold text-gray-700">Total Downtime (hrs)</h3>
                <p id="totalDowntime" class="text-3xl font-bold text-red-600 mt-2">0</p>
            </div>
            <div class="bg-white p-6 rounded-lg shadow-lg">
                <h3 class="text-lg font-semibold text-gray-700">Canceled Events</h3>
                <p id="canceledEvents" class="text-3xl font-bold text-yellow-600 mt-2">0</p>
            </div>
            <div class="bg-white p-6 rounded-lg shadow-lg">
                <h3 class="text-lg font-semibold text-gray-700">Avg Downtime (sec)</h3>
                <p id="avgDowntime" class="text-3xl font-bold text-green-600 mt-2">0</p>
            </div>
            <div class="bg-white p-6 rounded-lg shadow-lg">
                <h3 class="text-lg font-semibold text-gray-700">Availability Rate (%)</h3>
                <p id="availabilityRate" class="text-3xl font-bold text-purple-600 mt-2">0</p>
            </div>
            <div class="bg-white p-6 rounded-lg shadow-lg">
                <h3 class="text-lg font-semibold text-gray-700">Failure Rate (per hr)</h3>
                <p id="failureRate" class="text-3xl font-bold text-orange-600 mt-2">0</p>
            </div>
            <div class="bg-white p-6 rounded-lg shadow-lg">
                <h3 class="text-lg font-semibold text-gray-700">MTTR (sec)</h3>
                <p id="mttr" class="text-3xl font-bold text-teal-600 mt-2">0</p>
            </div>
            <div class="bg-white p-6 rounded-lg shadow-lg">
                <h3 class="text-lg font-semibold text-gray-700">MTBF (hrs)</h3>
                <p id="mtbf" class="text-3xl font-bold text-indigo-600 mt-2">0</p>
            </div>
            <div class="bg-white p-6 rounded-lg shadow-lg">
                <h3 class="text-lg font-semibold text-gray-700">Most Common Event Type</h3>
                <p id="mostCommonEventType" class="text-3xl font-bold text-pink-600 mt-2">N/A</p>
            </div>
            <div class="bg-white p-6 rounded-lg shadow-lg">
                <h3 class="text-lg font-semibold text-gray-700">Most Active User</h3>
                <p id="mostActiveUser" class="text-3xl font-bold text-cyan-600 mt-2">N/A</p>
            </div>
            <div class="bg-white p-6 rounded-lg shadow-lg">
                <h3 class="text-lg font-semibold text-gray-700">Top Resolver</h3>
                <p id="topResolver" class="text-3xl font-bold text-lime-600 mt-2">N/A</p>
            </div>
            <div class="bg-white p-6 rounded-lg shadow-lg">
                <h3 class="text-lg font-semibold text-gray-700">Most Common Maintenance Type</h3>
                <p id="mostCommonBreakdownType" class="text-3xl font-bold text-amber-600 mt-2">N/A</p>
            </div>
        </div>

        <!-- Charts -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <div class="bg-white p-6 rounded-lg shadow-lg">
                <h2 class="text-xl font-semibold text-gray-800 mb-4">Total Events per Machine</h2>
                <canvas id="eventsPerMachineChart"></canvas>
            </div>
            <div class="bg-white p-6 rounded-lg shadow-lg">
                <h2 class="text-xl font-semibold text-gray-800 mb-4">Events by Type</h2>
                <canvas id="eventsByTypeChart"></canvas>
            </div>
            <div class="bg-white p-6 rounded-lg shadow-lg">
                <h2 class="text-xl font-semibold text-gray-800 mb-4">Total Downtime per Machine (hours)</h2>
                <canvas id="totalDowntimeChart"></canvas>
            </div>
            <div class="bg-white p-6 rounded-lg shadow-lg">
                <h2 class="text-xl font-semibold text-gray-800 mb-4">Downtime Events per Machine</h2>
                <canvas id="downtimePerMachineChart"></canvas>
            </div>
            <div class="bg-white p-6 rounded-lg shadow-lg">
                <h2 class="text-xl font-semibold text-gray-800 mb-4">Canceled Events per Machine</h2>
                <canvas id="canceledEventsChart"></canvas>
            </div>
            <div class="bg-white p-6 rounded-lg shadow-lg">
                <h2 class="text-xl font-semibold text-gray-800 mb-4">Average Downtime Duration (seconds)</h2>
                <canvas id="avgDowntimeDurationChart"></canvas>
            </div>
            <div class="bg-white p-6 rounded-lg shadow-lg">
                <h2 class="text-xl font-semibold text-gray-800 mb-4">Maintenance Causes</h2>
                <canvas id="breakdownCausesChart"></canvas>
            </div>
            <div class="bg-white p- maintenance_arrival_user_id p-6 rounded-lg shadow-lg">
                <h2 class="text-xl font-semibold text-gray-800 mb-4">User Activity Count</h2>
                <canvas id="userActivityChart"></canvas>
            </div>
            <div class="bg-white p-6 rounded-lg shadow-lg">
                <h2 class="text-xl font-semibold text-gray-800 mb-4">Maintenance Resolution Time (seconds)</h2>
                <canvas id="breakdownResolutionTimeChart"></canvas>
            </div>
            <div class="bg-white p-6 rounded-lg shadow-lg">
                <h2 class="text-xl font-semibold text-gray-800 mb-4">Daily Event Distribution</h2>
                <canvas id="dailyEventDistributionChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        const chartColors = {
            primary: ['#3B82F6', '#60A5FA', '#93C5FD', '#BFDBFE', '#DBEAFE'],
            secondary: ['#EF4444', '#F87171', '#FCA5A5', '#FECACA', '#FEE2E2'],
            accent: ['#10B981', '#34D399', '#6EE7B7', '#A7F3D0', '#D1FAE5'],
            warning: ['#F59E0B', '#FBBF24', '#FCD34D', '#FDE68A', '#FEF3C7'],
            info: ['#8B5CF6', '#A78BFA', '#C4B5FD', '#DDD6FE', '#EDE9FE']
        };

        async function fetchAnalytics(startDate, endDate) {
            try {
                const response = await fetch('http://10.110.30.15:1250/api/all_events');
                if (!response.ok) throw new Error('Failed to fetch events data');
                const data = await response.json();
                let events = data.events || [];

                // Correct field mappings
                events = events.map(event => ({
                    ...event,
                    machine: event.duration, // "Machine1"
                    timestamp: event.machine, // "Wed, 07 May 2025 08:43:55 GMT"
                    duration: event.timestamp // "20.4165"
                }));

                // Filter events by date range
                if (startDate && endDate) {
                    events = events.filter(event => {
                        const eventDate = new Date(event.timestamp).toISOString().split('T')[0];
                        return eventDate >= startDate && eventDate <= endDate;
                    });
                }

                // Process events to compute analytics
                const eventsPerMachine = events.reduce((acc, event) => {
                    const machine = event.machine;
                    acc[machine] = acc[machine] || { machine, event_count: 0 };
                    acc[machine].event_count++;
                    return acc;
                }, {});

                const eventsByType = events.reduce((acc, event) => {
                    const type = event.event_type;
                    acc[type] = acc[type] || { event_type: type, event_count: 0 };
                    acc[type].event_count++;
                    return acc;
                }, {});

                const totalDowntimePerMachine = events.reduce((acc, event) => {
                    const machine = event.machine;
                    const duration = event.duration === 'None' ? 0 : parseFloat(event.duration) || 0;
                    acc[machine] = acc[machine] || { machine, total_downtime: 0 };
                    acc[machine].total_downtime += duration / 3600; // Convert to hours
                    return acc;
                }, {});

                const downtimePerMachine = events.filter(event => event.event_type === 'downtime').reduce((acc, event) => {
                    const machine = event.machine;
                    acc[machine] = acc[machine] || { machine, downtime_count: 0 };
                    acc[machine].downtime_count++;
                    return acc;
                }, {});

                const canceledEvents = events.filter(event => event.cancel_reason || event.status === 'canceled').reduce((acc, event) => {
                    const machine = event.machine;
                    acc[machine] = acc[machine] || { machine, canceled_count: 0 };
                    acc[machine].canceled_count++;
                    return acc;
                }, {});

                const avgDowntimeDuration = events.filter(event => event.duration && event.duration !== 'None' && event.event_type === 'downtime').reduce((acc, event) => {
                    const machine = event.machine;
                    acc[machine] = acc[machine] || { machine, avg_duration: 0, count: 0 };
                    acc[machine].avg_duration += parseFloat(event.duration);
                    acc[machine].count++;
                    return acc;
                }, {});
                Object.values(avgDowntimeDuration).forEach(item => {
                    item.avg_duration = item.count ? item.avg_duration / item.count : 0;
                });

                const breakdownCauses = events.filter(event => event.event_type === 'maintenance' && event.reason).reduce((acc, event) => {
                    const type = event.reason; // Use reason as maintenance type
                    acc[type] = acc[type] || { breakdown_type: type, count: 0 };
                    acc[type].count++;
                    return acc;
                }, {});

                const userActivity = events.reduce((acc, event) => {
                    const user = event.start_user_id || 'N/A';
                    acc[user] = acc[user] || { user_id: user, event_count: 0, maintenance_count: 0 };
                    acc[user].event_count++;
                    if (event.event_type === 'maintenance' && event.maintenance_arrival_user_id) {
                        acc[user].maintenance_count++;
                    }
                    return acc;
                }, {});

                const breakdownResolutionTime = events.filter(event => event.event_type === 'maintenance' && event.end_user_id && event.end_user_id !== 'N/A').reduce((acc, event) => {
                    const type = event.reason;
                    acc[type] = acc[type] || { breakdown_type: type, total_time: 0, count: 0 };
                    acc[type].total_time += parseFloat(event.duration);
                    acc[type].count++;
                    return acc;
                }, {});
                Object.values(breakdownResolutionTime).forEach(item => {
                    item.avg_time = item.count ? item.total_time / item.count : 0;
                });

                const dailyEventDistribution = events.reduce((acc, event) => {
                    const date = new Date(event.timestamp).toISOString().split('T')[0];
                    acc[date] = acc[date] || { date, event_count: 0 };
                    acc[date].event_count++;
                    return acc;
                }, {});

                const kpis = {
                    availability_rate: events.length ? (1 - (events.filter(e => e.event_type === 'downtime' || e.event_type === 'maintenance').length / events.length)) * 100 : 0,
                    failure_rate: events.length ? events.filter(e => e.event_type === 'maintenance').length / (events.length / 24) : 0,
                    mttr: events.filter(e => e.end_user_id && e.end_user_id !== 'N/A').length ? events.reduce((sum, e) => sum + (parseFloat(e.duration) || 0), 0) / events.filter(e => e.end_user_id && e.end_user_id !== 'N/A').length : 0,
                    mtbf: events.filter(e => e.event_type === 'maintenance').length ? (events.length / events.filter(e => e.event_type === 'maintenance').length) / 3600 : 0
                };

                const mostCommonEventType = Object.values(eventsByType).reduce((max, item) => item.event_count > (max.event_count || 0) ? item : max, {}).event_type || 'N/A';
                const mostActiveUser = Object.values(userActivity).reduce((max, item) => item.event_count > (max.event_count || 0) ? item : max, {}).user_id || 'N/A';
                const topResolver = events.filter(e => e.end_user_id && e.end_user_id !== 'N/A').reduce((acc, e) => {
                    const resolver = e.end_user_id;
                    acc[resolver] = acc[resolver] || { resolver_id: resolver, resolve_count: 0 };
                    acc[resolver].resolve_count++;
                    return acc;
                }, {});
                const topResolverId = Object.values(topResolver).reduce((max, item) => item.resolve_count > (max.resolve_count || 0) ? item : max, {}).resolver_id || 'N/A';
                const mostCommonBreakdownType = Object.values(breakdownCauses).reduce((max, item) => item.count > (max.count || 0) ? item : max, {}).breakdown_type || 'N/A';

                const analytics = {
                    raw_events: events,
                    events_per_machine: Object.values(eventsPerMachine),
                    events_by_type: Object.values(eventsByType),
                    total_downtime_per_machine: Object.values(totalDowntimePerMachine),
                    downtime_per_machine: Object.values(downtimePerMachine),
                    canceled_events: Object.values(canceledEvents),
                    avg_downtime_duration: Object.values(avgDowntimeDuration),
                    breakdown_causes: Object.values(breakdownCauses),
                    user_activity: Object.values(userActivity),
                    breakdown_resolution_time: Object.values(breakdownResolutionTime),
                    daily_event_distribution: Object.values(dailyEventDistribution),
                    kpis,
                    most_common_event_type: mostCommonEventType,
                    most_active_user: mostActiveUser,
                    top_resolver: topResolverId,
                    most_common_breakdown_type: mostCommonBreakdownType
                };

                console.log('Processed Analytics:', analytics);
                return analytics;
            } catch (error) {
                console.error('Error fetching analytics:', error);
                return {};
            }
        }

        function createHorizontalBarChart(ctx, labels, data, label, colors = chartColors.primary) {
            if (!data || !data.length) {
                ctx.fillText('No Data Available', 10, 50);
                return null;
            }
            return new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: label,
                        data: data,
                        backgroundColor: colors[0],
                        borderColor: colors[0],
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y',
                    scales: {
                        x: {
                            beginAtZero: true,
                            grid: { display: false }
                        },
                        y: {
                            grid: { display: false }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: true }
                    }
                }
            });
        }

        function createDoughnutChart(ctx, labels, data, label) {
            if (!data || !data.length) {
                ctx.fillText('No Data Available', 10, 50);
                return null;
            }
            return new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        label: label,
                        data: data,
                        backgroundColor: chartColors.primary,
                        borderColor: chartColors.primary.map(color => color.replace('0.7', '1')),
                        borderWidth: 1
                    }]
                },
                options: {
                    plugins: {
                        legend: { position: 'right' },
                        tooltip: { enabled: true }
                    }
                }
            });
        }

        function createBarChart(ctx, labels, data, label, colors = chartColors.accent) {
            if (!data || !data.length) {
                ctx.fillText('No Data Available', 10, 50);
                return null;
            }
            return new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: label,
                        data: data,
                        backgroundColor: colors[0],
                        borderColor: colors[0],
                        borderWidth: 1
                    }]
                },
                options: {
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: { display: false }
                        },
                        x: {
                            grid: { display: false }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: true }
                    }
                }
            });
        }

        async function initCharts(startDate, endDate) {
            const analytics = await fetchAnalytics(startDate, endDate);

            // Update Cards
            document.getElementById('totalEvents').textContent = analytics.events_per_machine?.reduce((sum, item) => sum + (item.event_count || 0), 0) || 0;
            document.getElementById('totalDowntime').textContent = (analytics.total_downtime_per_machine?.reduce((sum, item) => sum + (item.total_downtime || 0), 0) || 0).toFixed(2);
            document.getElementById('canceledEvents').textContent = analytics.canceled_events?.reduce((sum, item) => sum + (item.canceled_count || 0), 0) || 0;
            document.getElementById('avgDowntime').textContent = analytics.avg_downtime_duration?.length ? 
                (analytics.avg_downtime_duration.reduce((sum, item) => sum + (item.avg_duration || 0), 0) / analytics.avg_downtime_duration.length).toFixed(2) : 0;
            document.getElementById('availabilityRate').textContent = (analytics.kpis?.availability_rate || 0).toFixed(2);
            document.getElementById('failureRate').textContent = (analytics.kpis?.failure_rate || 0).toFixed(2);
            document.getElementById('mttr').textContent = (analytics.kpis?.mttr || 0).toFixed(2);
            document.getElementById('mtbf').textContent = (analytics.kpis?.mtbf || 0).toFixed(2);
            document.getElementById('mostCommonEventType').textContent = analytics.most_common_event_type || 'N/A';
            document.getElementById('mostActiveUser').textContent = analytics.most_active_user || 'N/A';
            document.getElementById('topResolver').textContent = analytics.top_resolver || 'N/A';
            document.getElementById('mostCommonBreakdownType').textContent = analytics.most_common_breakdown_type || 'N/A';

            // Total Events per Machine
            const eventsPerMachineCtx = document.getElementById('eventsPerMachineChart').getContext('2d');
            createHorizontalBarChart(
                eventsPerMachineCtx,
                analytics.events_per_machine?.map(item => item.machine) || [],
                analytics.events_per_machine?.map(item => item.event_count || 0) || [],
                'Event Count',
                chartColors.primary
            );

            // Events by Type
            const eventsByTypeCtx = document.getElementById('eventsByTypeChart').getContext('2d');
            createDoughnutChart(
                eventsByTypeCtx,
                analytics.events_by_type?.map(item => item.event_type) || [],
                analytics.events_by_type?.map(item => item.event_count || 0) || [],
                'Events by Type'
            );

            // Total Downtime per Machine
            const totalDowntimeCtx = document.getElementById('totalDowntimeChart').getContext('2d');
            createHorizontalBarChart(
                totalDowntimeCtx,
                analytics.total_downtime_per_machine?.map(item => item.machine) || [],
                analytics.total_downtime_per_machine?.map(item => item.total_downtime || 0) || [],
                'Total Downtime (hours)',
                chartColors.secondary
            );

            // Downtime Events per Machine
            const downtimePerMachineCtx = document.getElementById('downtimePerMachineChart').getContext('2d');
            createHorizontalBarChart(
                downtimePerMachineCtx,
                analytics.downtime_per_machine?.map(item => item.machine) || [],
                analytics.downtime_per_machine?.map(item => item.downtime_count || 0) || [],
                'Downtime Events',
                chartColors.accent
            );

            // Canceled Events per Machine
            const canceledEventsCtx = document.getElementById('canceledEventsChart').getContext('2d');
            createHorizontalBarChart(
                canceledEventsCtx,
                analytics.canceled_events?.map(item => item.machine) || [],
                analytics.canceled_events?.map(item => item.canceled_count || 0) || [],
                'Canceled Events',
                chartColors.warning
            );

            // Average Downtime Duration
            const avgDowntimeDurationCtx = document.getElementById('avgDowntimeDurationChart').getContext('2d');
            createHorizontalBarChart(
                avgDowntimeDurationCtx,
                analytics.avg_downtime_duration?.map(item => item.machine) || [],
                analytics.avg_downtime_duration?.map(item => item.avg_duration || 0) || [],
                'Average Duration (seconds)',
                chartColors.accent
            );

            // Maintenance Causes
            const breakdownCausesCtx = document.getElementById('breakdownCausesChart').getContext('2d');
            createDoughnutChart(
                breakdownCausesCtx,
                analytics.breakdown_causes?.map(item => item.breakdown_type) || [],
                analytics.breakdown_causes?.map(item => item.count || 0) || [],
                'Maintenance Causes'
            );

            // User Activity Count
            const userActivityCtx = document.getElementById('userActivityChart').getContext('2d');
            createHorizontalBarChart(
                userActivityCtx,
                analytics.user_activity?.map(item => item.user_id) || [],
                analytics.user_activity?.map(item => item.event_count || 0) || [],
                'Event Count',
                chartColors.info
            );

            // Maintenance Resolution Time
            const breakdownResolutionTimeCtx = document.getElementById('breakdownResolutionTimeChart').getContext('2d');
            createHorizontalBarChart(
                breakdownResolutionTimeCtx,
                analytics.breakdown_resolution_time?.map(item => item.breakdown_type) || [],
                analytics.breakdown_resolution_time?.map(item => item.avg_time || 0) || [],
                'Average Resolution Time (seconds)',
                chartColors.secondary
            );

            // Daily Event Distribution
            const dailyEventDistributionCtx = document.getElementById('dailyEventDistributionChart').getContext('2d');
            createBarChart(
                dailyEventDistributionCtx,
                analytics.daily_event_distribution?.map(item => item.date) || [],
                analytics.daily_event_distribution?.map(item => item.event_count || 0) || [],
                'Event Count',
                chartColors.accent
            );

            // Store analytics for export
            window.currentAnalytics = analytics;
        }

        function exportToExcel() {
            const analytics = window.currentAnalytics || {};
            const wb = XLSX.utils.book_new();

            // Helper function to apply styles to cells
            const applyCellStyle = (ws, range, style) => {
                for (let row = range.s.r; row <= range.e.r; row++) {
                    for (let col = range.s.c; col <= range.e.c; col++) {
                        const cellRef = XLSX.utils.encode_cell({ r: row, c: col });
                        if (!ws[cellRef]) ws[cellRef] = { t: 's', v: '' };
                        ws[cellRef].s = { ...ws[cellRef].s, ...style };
                    }
                }
            };

            // Define professional styles
            const titleStyle = {
                font: { name: 'Calibri', sz: 18, bold: true, color: { rgb: "FFFFFF" } },
                fill: { fgColor: { rgb: "4361EE" } },
                alignment: { horizontal: "center", vertical: "center" },
                border: {
                    top: { style: "medium", color: { rgb: "000000" } },
                    bottom: { style: "medium", color: { rgb: "000000" } },
                    left: { style: "medium", color: { rgb: "000000" } },
                    right: { style: "medium", color: { rgb: "000000" } }
                }
            };

            const headerStyle = {
                font: { name: 'Calibri', sz: 12, bold: true, color: { rgb: "FFFFFF" } },
                fill: { fgColor: { rgb: "3A0CA3" } },
                alignment: { horizontal: "center", vertical: "center", wrapText: true },
                border: {
                    top: { style: "thin", color: { rgb: "000000" } },
                    bottom: { style: "thin", color: { rgb: "000000" } },
                    left: { style: "thin", color: { rgb: "000000" } },
                    right: { style: "thin", color: { rgb: "000000" } }
                }
            };

            const dataStyle = {
                font: { name: 'Calibri', sz: 11 },
                border: {
                    top: { style: "thin", color: { rgb: "000000" } },
                    bottom: { style: "thin", color: { rgb: "000000" } },
                    left: { style: "thin", color: { rgb: "000000" } },
                    right: { style: "thin", color: { rgb: "000000" } }
                },
                alignment: { vertical: "center", wrapText: true }
            };

            const altRowStyle = {
                font: { name: 'Calibri', sz: 11 },
                fill: { fgColor: { rgb: "E6F0FA" } }, // Light blue for alternating rows
                border: {
                    top: { style: "thin", color: { rgb: "000000" } },
                    bottom: { style: "thin", color: { rgb: "000000" } },
                    left: { style: "thin", color: { rgb: "000000" } },
                    right: { style: "thin", color: { rgb: "000000" } }
                },
                alignment: { vertical: "center", wrapText: true }
            };

            const highlightStyle = {
                font: { name: 'Calibri', sz: 11, bold: true },
                fill: { fgColor: { rgb: "FECACA" } }, // Light red for highlighting
                border: {
                    top: { style: "thin", color: { rgb: "000000" } },
                    bottom: { style: "thin", color: { rgb: "000000" } },
                    left: { style: "thin", color: { rgb: "000000" } },
                    right: { style: "thin", color: { rgb: "000000" } }
                },
                alignment: { vertical: "center", wrapText: true }
            };

            // Sheet 1: Raw Events
            const eventHeaders = ['ID', 'Event Type', 'Machine', 'Timestamp', 'Duration (sec)', 'Start User ID', 'Maintenance Arrival User ID', 'End User ID (Resolver)', 'Reason (Maintenance Type)', 'Cancel Reason', 'Status', 'Start Comment', 'End Comment'];
            const eventData = analytics.raw_events?.map(event => [
                event.id,
                event.event_type,
                event.machine,
                event.duration === 'None' ? 0 : parseFloat(event.duration) || 0,
                event.timestamp,
                event.start_user_id || 'N/A',
                event.maintenance_arrival_user_id || 'N/A',
                event.end_user_id || 'N/A',
                event.reason || 'N/A',
                event.cancel_reason || 'N/A',
                event.status,
                event.start_comment || 'N/A',
                event.end_comment || 'N/A'
            ]) || [];

            const eventWs = XLSX.utils.aoa_to_sheet([
                [`Analytics Dashboard - Event Report (Generated on ${new Date().toLocaleDateString()})`],
                ['Detailed event log with status, duration, and user activity'],
                [],
                eventHeaders,
                ...eventData
            ]);

            // Merge cells for title and subtitle
            eventWs['!merges'] = [
                { s: { r: 0, c: 0 }, e: { r: 0, c: eventHeaders.length - 1 } },
                { s: { r: 1, c: 0 }, e: { r: 1, c: eventHeaders.length - 1 } }
            ];
            eventWs['!cols'] = eventHeaders.map((_, i) => ({ wch: i === 3 || i === 8 || i === 11 || i === 12 ? 30 : 15 }));
            eventWs['!rows'] = [{ hpt: 30 }, { hpt: 20 }];

            // Apply styles for events sheet
            applyCellStyle(eventWs, { s: { r: 0, c: 0 }, e: { r: 0, c: eventHeaders.length - 1 } }, titleStyle);
            applyCellStyle(eventWs, { s: { r: 1, c: 0 }, e: { r: 1, c: eventHeaders.length - 1 } }, {
                font: { name: 'Calibri', sz: 12, italic: true, color: { rgb: "333333" } },
                alignment: { horizontal: "center", vertical: "center" }
            });
            applyCellStyle(eventWs, { s: { r: 3, c: 0 }, e: { r: 3, c: eventHeaders.length - 1 } }, headerStyle);
            eventData.forEach((row, idx) => {
                const rowNum = idx + 4;
                const isCanceled = row[10] === 'canceled';
                const duration = row[3];
                const style = isCanceled ? highlightStyle : (duration > 3600 ? { ...dataStyle, fill: { fgColor: { rgb: "FEF3C7" } } } : (rowNum % 2 === 0 ? altRowStyle : dataStyle));
                applyCellStyle(eventWs, { s: { r: rowNum, c: 0 }, e: { r: rowNum, c: eventHeaders.length - 1 } }, style);
            });

            // Freeze panes
            eventWs['!freeze'] = { xSplit: 1, ySplit: 4 };
            XLSX.utils.book_append_sheet(wb, eventWs, 'Events');

            // Sheet 2: User Summary
            const userHeaders = ['User ID', 'Total Events Initiated', 'Maintenance Arrivals'];
            const userData = analytics.user_activity?.map(item => [
                item.user_id,
                item.event_count,
                item.maintenance_count
            ]) || [];

            const userWs = XLSX.utils.aoa_to_sheet([
                [`Analytics Dashboard - User Summary (Generated on ${new Date().toLocaleDateString()})`],
                ['Summary of user activity and maintenance involvement'],
                [],
                userHeaders,
                ...userData
            ]);

            // Merge cells for title and subtitle
            userWs['!merges'] = [
                { s: { r: 0, c: 0 }, e: { r: 0, c: userHeaders.length - 1 } },
                { s: { r: 1, c: 0 }, e: { r: 1, c: userHeaders.length - 1 } }
            ];
            userWs['!cols'] = userHeaders.map(() => ({ wch: 20 }));
            userWs['!rows'] = [{ hpt: 30 }, { hpt: 20 }];

            // Apply styles for user summary sheet
            applyCellStyle(userWs, { s: { r: 0, c: 0 }, e: { r: 0, c: userHeaders.length - 1 } }, titleStyle);
            applyCellStyle(userWs, { s: { r: 1, c: 0 }, e: { r: 1, c: userHeaders.length - 1 } }, {
                font: { name: 'Calibri', sz: 12, italic: true, color: { rgb: "333333" } },
                alignment: { horizontal: "center", vertical: "center" }
            });
            applyCellStyle(userWs, { s: { r: 3, c: 0 }, e: { r: 3, c: userHeaders.length - 1 } }, headerStyle);
            userData.forEach((row, idx) => {
                const rowNum = idx + 4;
                const eventCount = row[1];
                const style = eventCount > 10 ? { ...dataStyle, fill: { fgColor: { rgb: "D1FAE5" } } } : (rowNum % 2 === 0 ? altRowStyle : dataStyle);
                applyCellStyle(userWs, { s: { r: rowNum, c: 0 }, e: { r: rowNum, c: userHeaders.length - 1 } }, style);
            });

            // Freeze panes
            userWs['!freeze'] = { xSplit: 1, ySplit: 4 };
            XLSX.utils.book_append_sheet(wb, userWs, 'User Summary');

            // Sheet 3: Aggregated Metrics
            const metricHeaders = ['Metric', 'Value'];
            const metricData = [
                ['Total Events', analytics.events_per_machine?.reduce((sum, item) => sum + (item.event_count || 0), 0) || 0],
                ['Total Downtime (hrs)', (analytics.total_downtime_per_machine?.reduce((sum, item) => sum + (item.total_downtime || 0), 0) || 0).toFixed(2)],
                ['Canceled Events', analytics.canceled_events?.reduce((sum, item) => sum + (item.canceled_count || 0), 0) || 0],
                ['Avg Downtime (sec)', analytics.avg_downtime_duration?.length ? (analytics.avg_downtime_duration.reduce((sum, item) => sum + (item.avg_duration || 0), 0) / analytics.avg_downtime_duration.length).toFixed(2) : 0],
                ['Availability Rate (%)', (analytics.kpis?.availability_rate || 0).toFixed(2)],
                ['Failure Rate (per hr)', (analytics.kpis?.failure_rate || 0).toFixed(2)],
                ['MTTR (sec)', (analytics.kpis?.mttr || 0).toFixed(2)],
                ['MTBF (hrs)', (analytics.kpis?.mtbf || 0).toFixed(2)],
                ['Most Common Event Type', analytics.most_common_event_type || 'N/A'],
                ['Most Active User', analytics.most_active_user || 'N/A'],
                ['Top Resolver', analytics.top_resolver || 'N/A'],
                ['Most Common Maintenance Type', analytics.most_common_breakdown_type || 'N/A']
            ];

            const metricWs = XLSX.utils.aoa_to_sheet([
                [`Analytics Dashboard - Key Performance Metrics (Generated on ${new Date().toLocaleDateString()})`],
                ['Summary of operational KPIs and system performance'],
                [],
                metricHeaders,
                ...metricData
            ]);

            // Merge cells for title and subtitle
            metricWs['!merges'] = [
                { s: { r: 0, c: 0 }, e: { r: 0, c: metricHeaders.length - 1 } },
                { s: { r: 1, c: 0 }, e: { r: 1, c: metricHeaders.length - 1 } }
            ];
            metricWs['!cols'] = [{ wch: 35 }, { wch: 25 }];
            metricWs['!rows'] = [{ hpt: 30 }, { hpt: 20 }];

            // Apply styles for metrics sheet
            applyCellStyle(metricWs, { s: { r: 0, c: 0 }, e: { r: 0, c: metricHeaders.length - 1 } }, titleStyle);
            applyCellStyle(metricWs, { s: { r: 1, c: 0 }, e: { r: 1, c: metricHeaders.length - 1 } }, {
                font: { name: 'Calibri', sz: 12, italic: true, color: { rgb: "333333" } },
                alignment: { horizontal: "center", vertical: "center" }
            });
            applyCellStyle(metricWs, { s: { r: 3, c: 0 }, e: { r: 3, c: metricHeaders.length - 1 } }, headerStyle);
            metricData.forEach((row, idx) => {
                const rowNum = idx + 4;
                const value = parseFloat(row[1]);
                const style = (row[0] === 'Total Downtime (hrs)' && value > 10) ? { ...dataStyle, fill: { fgColor: { rgb: "FEF3C7" } } } : 
                             (row[0] === 'Availability Rate (%)' && value < 90) ? { ...dataStyle, fill: { fgColor: { rgb: "FECACA" } } } :
                             (rowNum % 2 === 0 ? altRowStyle : dataStyle);
                applyCellStyle(metricWs, { s: { r: rowNum, c: 0 }, e: { r: rowNum, c: metricHeaders.length - 1 } }, style);
            });

            // Freeze panes
            metricWs['!freeze'] = { xSplit: 1, ySplit: 4 };
            XLSX.utils.book_append_sheet(wb, metricWs, 'Key Metrics');

            // Generate and download the Excel file
            const wbout = XLSX.write(wb, { bookType: 'xlsx', type: 'binary' });
            const s2ab = (s) => {
                const buf = new ArrayBuffer(s.length);
                const view = new Uint8Array(buf);
                for (let i = 0; i < s.length; i++) view[i] = s.charCodeAt(i) & 0xFF;
                return buf;
            };
            const blob = new Blob([s2ab(wbout)], { type: 'application/octet-stream' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `Analytics_Report_${new Date().toISOString().split('T')[0]}.xlsx`;
            a.click();
            window.URL.revokeObjectURL(url);
        }

        document.addEventListener('DOMContentLoaded', () => {
            initCharts();
            document.getElementById('applyFilter').addEventListener('click', () => {
                const startDate = document.getElementById('startDate').value;
                const endDate = document.getElementById('endDate').value;
                if (startDate && endDate) {
                    initCharts(startDate, endDate);
                }
            });
            document.getElementById('resetFilter').addEventListener('click', () => {
                document.getElementById('startDate').value = '';
                document.getElementById('endDate').value = '';
                initCharts();
            });
            document.getElementById('exportExcel').addEventListener('click', exportToExcel);
        });
    </script>
</body>
</html>